#ifndef __MESH_H__
#define __MESH_H__

#include <stdio.h>

/*! \mainpage Libmesh package overview 
 *
 * Libmesh provides an API to create regular/irregular meshes, 
 * load data into mesh cells, and navigate through
 * the mesh.
 *
 *\section descr Mesh description
 *  
 *  The mesh should be described with an XML file format
 *  with a root element \<mesh\>  whose attributes define the zone
 *  covered by the mesh. The attributes define the lattitudinal
 *  and longitudinal extremum angles of the zone (in degrees). 
 *  The base cell size is also expressed in degrees with the attributes 
 *  lat-unit-size and lon-unit-size.
 *
 *  Here is an example :
\verbatim
<mesh lat-min="-90"     lat-max="90" 
      lon-min="0"       lon-max="360"
      lat-unit-size="1" lon-unit-size="0.6"> 
\endverbatim
 *   that covers the whole globe
 *   with a base cell size 1 x 0.6 degrees.
 *
 *  
 *
 *  Sub-elements of \<mesh\> describe the layer model to use(\<model\>), 
 *  and if it is necessary to import data into the mesh (\<data\>).
 *  The model consists in an arbitrary number of 
 *  \<layer\> elements. Each layer has a starts and stops at a certain
 *  depth, specified with attributes zstart and zend. The longitudianl and 
 *  lattidudinal widths of the cell may be specified in numbers of base cell size,
 *  with lat-unit and lon-unit attributes. 
 *
 *  A model example with one layer,
\verbatim
<model>
	<layer name="Crust" zstart="0" zend="20" lat-unit="1" lon-unit="2"/>
</model>
\endverbatim
 *  defines cells that are 20 kms high, 1 degree wide in lat and 1.2 deg wide in longitude.
 *
 * A second example where we import data into the mesh,
\verbatim
<data format="r2m">
	<file name="filetoimport1.r2m" domain="1/2">
	<file name="filetoimport2.r2m" domain="1/2">
</data>
\endverbatim
 * defines the format of the files to import (here r2m), and the files themselves.
 *
 *  
 *
 *  The mesh_init_from_file() function parses an XML file and
 *  creates a mesh structure that can receive data afterwards.
 *  A variant of this method is mesh_init_from_memory() that
 *  parses an XML string. 
 *  Auxiliary functions are load_file_to_memory() and 
 *  unload_file_from_memory() that respectively fill and free a memory 
 *  zone with a file contents.
 *
 * \section management Mesh management
 * make_mesh() and free_mesh()
 *
 * \section navigation Mesh navigation
 * The API provides move_in_mesh() to get a pointer to a given cell_t 
 * cell element of the mesh.
 *
 * \section importation Data importation
 * A mesh structure can be initialized with cells data generated by \b ray2mesh package.
 * The data set produced by ray2mesh can be <b>sco</b> or <b>r2m</b> formated files, 
 * and our mesh can import them using respectively import2mesh_sco_file() and import2mesh_r2m_file().
 *
 * \warning when importing cells data take care to use the same XML mesh file used by ray2mesh.
 *
 * \section slice Slice mode
 * When using huge quantity of rays in a high density mesh, 
 * the computer memory can be quickly exhausted.
 * To reduced the memory footprint, one can use the <b>slice mode</b>, where a mesh
 * is splited in a non overlapping set of smaller meshes. The \b mesh_split program take 
 * as arguments the XML desciption of the mesh to be splited, and the number of divisions
 * in latitude and longitude.
 * To merge all the individual ray2mesh results, one by slice,   
 * we import all the ray2mesh data coming from a sliced mesh (either \b sco or \b r2m
 * format). Each slice must have \b offset and \b xmlfile tags defined in the file header.
 * User must provides \b -s flag to enable the <b>slice mode</b> (FIXME: trying to remove
 * the offset stuff).
 *
*/

/**
 * A mesh (typically only one is used) is stored inside
 * a such structure. It stores its parameters (such as number
 * of layers, depths of layers, cell sizes, and contains links 
 * to several layers. It is accessible via its first cell.
 */
struct mesh_t {
    long int ncells;                    /**< number of cells in the mesh  */
    int nlayers;                        /**< number of layers in the mesh */
    struct layer_t **layer;             /**< layers array */
    struct cell_t *cell;                /**< initial cell of the mesh */
    struct mesh_parameter_t *parameter; /**< mesh parameters */
    struct point3d_tab_t
    *allocated_points;                  /**< the allocated point in the mesh */
    struct cell_tab_t *allocated_cells; /**< the allocated cell in the mesh */
    char *xml_filename;                 /**< xml mesh file */
    struct mesh_data_t **data;          /**< data imported into the mesh */
    struct mesh_overlap_t *overlap;     /**< keep base info if the mesh use overlapping */
    long int max_rayid;                 /**< store the max rayid imported into this mesh */
    int nb_total_metacell;              /**< how many metacell in all layers */
    int *nb_metacell;                   /**< how many metacell in each layer */
    struct cell_t ***metacell;          /**< metacell (heading cell) list available 
					                         in the mesh, one list by layer */
};

/**
 * One can import data into the mesh. 
 */
struct mesh_data_t {
    char *format;
    int ndatafile;                      /**< nb of data file to import into the mesh */
    char *directory;                    /**< data files directory */
    char **filename;                    /**< data file name to import into the mesh */
};

/**
 * Store information about the overlapping
 * such as the size of the overlapping zone around a mesh described 
 * with base_parameter.
 */
struct mesh_overlap_t {
    int overlap_size;                           /**< number of cell used to do the overlap **/
    struct mesh_parameter_t *base_parameter;    /**< mesh parameters before applying the overlap **/
    struct coord_z3_t *first_cell_in_noz;       /**< first cell in no overlapped zone */
    struct coord_z3_t *last_cell_in_noz;        /**< last cell in no overlapped zone */
    struct coord_z3_t *first_cell_in_z1;        /**< first cell in overlapped zone1 */
    struct coord_z3_t *last_cell_in_z1;         /**< last  cell in overlapped zone1 */
};

/**
 * A mesh has global properties described by some parameters. 
 * Parameters specify the covered geographic zone
 * and the unit length of cells (that can be refined for each layer).
 */
struct mesh_parameter_t {
    double lat_min;             /**< mesh earth from this latitude */
    double lat_max;             /**< mesh earth up to this latitude */
    double lon_min;             /**< mesh earth from this longitude */
    double lon_max;             /**< mesh earth up to this longitude */
    double lat_unit_size;       /**< unitary lenght in latitude of one cell  */
    double lon_unit_size;       /**< unitary lenght in longitude of one cell  */
};

/**
 *\brief Provides version information on libmesh used 
 */
char *libmeshversion(void);

/**
 * \brief Load a mesh description from file into memory 
 *
 * Loads a mesh description file to memory and returns
 * an handle on the loaded memory zone.
 * This action is typically followed by a mesh_init_from_memory()
 * call.
 */
char *load_file_to_memory(char *filename, int *size);

/**
 * \brief Free memory used to store mesh description
 *
 * Used to free a mesh description loaded with load_file_to_memory()
 */
void unload_file_from_memory(char *addr, int size);

/**
 * \brief Load a mesh description into memory and return a mesh.
 *
 * Loads a mesh description from a file, into memory and initilizes
 * internal mesh structures. Return a mesh_t structure.
 */
struct mesh_t *mesh_init_from_file(char *conffile);

/**
 * \brief Load a mesh description from a string and return a mesh.
 *
 * Loads a mesh description from a contiguous memory zone whose size
 * is passed as a parameter and
 * initilizes internal mesh structures. Return a mesh_t structure.
 *
 * \param buffer the address where the description lies
 * \param size the number of bytes that should be read from buffer 
 *        to get the description
 * \param string to give a name to this mesh
 */
struct mesh_t *mesh_init_from_memory(char *buffer, int size, char *string);

/**\brief Return an XML fragment with the "data" tag. */
char *mesh_xml_data_string(char *filename, int nbfiles, int r2m);

/** \brief user only want to process layer = [begin_layer, end_layer] 
 * 
 * if begin_layer and end_layer are not defined by the user (ie. -1) 
 * select_mesh_layer() set the min layer to begin_layer, and max layer to end_layer.
 */

void select_mesh_layer(struct mesh_t *mesh, int *begin_layer,
                       int *end_layer);

/* \brief Alloc structure in a previously defined mesh */
struct mesh_overlap_t *mesh_overlap_alloc(struct mesh_t *mesh);
void update_layer_info(struct mesh_t *mesh);
void make_mesh(struct mesh_t *mesh);

/**
 * \brief Cleanup mesh memory occupation
 */
void free_mesh(struct mesh_t *mesh);
void mesh_dump(struct mesh_t *mesh);

/**
 * \brief dump_mesh_parameter : outputs the values of mesh parameters
 */
void mesh_dump_parameter(FILE * fd, char *pretxt, char *posttxt,
                         struct mesh_parameter_t *mp);
struct cell_t *move_in_mesh(struct mesh_t *mesh, struct cell_t *start_cell,
                            int lat_step, int lon_step, int layer_step);

/**\brief parse a string with coma separated atoms. */
char **parse_separated_list(char *str, char *sep);

/** \brief compute basic values for each layer **/
void update_layer_info(struct mesh_t *mesh);

/** \brief given a cell coord (x,y,z) return a unique cell Id */
long int linearize_cell_id(struct coord_z3_t *cell_id,
                           const struct mesh_t *mesh);
void unlinearize_cell_id(long int lcid, int *x, int *y, int *z,
                         const struct mesh_t *mesh);

/** \brief show sections included in the xml file.
 * IRM, irregular mesh files ie. metacells caracteristics,
 * SPARSE, rays lengths in the metacells,
 * SCO, cells/metacells values,
 * R2M, geometrics rays carateristics in the cells
 * RES, residus file
 **/
void mesh_show_sections(struct mesh_t *mesh);

/** \brief add a filename in a given section */
void mesh_add_data_filename(struct mesh_t *mesh, int format,
                            char *filename);

/** \brief remove all filename in a given section */
void mesh_remove_data_entry(struct mesh_t *mesh, int format);

/** \brief return the name of the xml section defined by format 
 * wich could be SPARSE,RES,IRM,R2M,SCO
 **/
char *mesh_get_section_name(int f);

#endif
